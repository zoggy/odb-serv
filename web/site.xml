<?xml version="1.0" encoding="ISO-8859-1" standalone="yes"?>
<site>
<title>Odb-server</title>
<side>
<section><page-toc></page-toc></section>
</side>
<header>
<navig/><!-- <lang-switch/>-->
</header>
<footer>
<navig/><!-- <lang-switch/>-->
</footer>
<page name="index" sidebar="true" >
<title>Odb-server</title>

<section name="main:whatis">
<title><en>What is Odb-server ?</en><fr>Qu'est-ce que Odb-server ?</fr></title>
<p>
<en>
</en>
<fr>Odb-server fournit un serveur offrant des services à des éditeurs de code et autres
environnements de développement intégrés (IDE) pour obtenir des informations
sur le code OCaml édité.
Une </fr>
<link href="refdoc/index.html"><fr>bibliothèque</fr></link>
<fr> est également fournie pour enrichir le serveur afin de fournir
des services supplémentaires.
</fr>
</p>
<linkline>
<link href="https://forge.ocamlcore.org/projects/odb-serv/"><en>Project page on OCaml Forge</en><fr>Page du projet sur la forge OCaml</fr></link>
<link href="http://caml.inria.fr/">Objective-Caml</link>
<link href="https://github.com/zoggy/odb-serv">Code on Github</link>
</linkline>
</section>

<section name="install"><title>Installation</title>
<p>
Pour l'instant, Odb-server est téléchargeable en utilisant git:
</p>
<pre class="shell">
# git clone git://github.com/zoggy/odb-serv.git
</pre>
<p>
<en>Then, follow the instructions in the </en>
<fr>Ensuite, suivre les instructions du fichier </fr>
<tt>INSTALL</tt>
<en> file coming with the distribution archive.</en>
<fr> inclus dans l'archive de distribution.</fr>
</p>
<p>
<en>These are are required to compile Odb-server:</en>
<fr>La compilation de Odb-server requiert:</fr>
</p>
<ul>
<li><link href="http://caml.inria.fr/">OCaml 3.12.0</link><en> or above,</en><fr> ou supérieur,</fr></li>
<li>make.</li>
</ul>
</section>

<section name="license">
<title>
<en>License</en>
<fr>Licence</fr>
</title>
<p>
<en>Odb-server is distributed under the GPL license version 2.</en>
<fr>Odb-server est distribué sous licence GPL version 2.</fr>
</p>
</section>

<section name="principle">
<title>Principes</title>
<p>
Il s'agit d'avoir un serveur auquel s'adresse l'éditeur ou l'IDE du développeur (emacs, chamo, vi, ...).
Chaque service est composé d'un nom d'outil (une chaîne de caractères) et d'une commande.
</p>
<p>
Les commandes sont de la même forme que les commandes shell, c'est-à-dire un nom de commande
et des arguments, avec des arguments séparés par des blancs et les guillemets et apostrophes pouvant
être utilisés de la même façon que dans un shell pour spécifier un argument contenant des blancs.
</p>
<p>
La communication avec le serveur se fait par l'intermédiaire d'un socket, et par un
<local href="protocol">protocole textuel</local>.
</p>
<p>
Le serveur de base offre les outils "server" et "project", supportant chacun diverses commandes.
Cependant, il peut être enrichi d'autres outils de deux façons:
</p>
<ol>
<li> soit par un plug-in indiqué sur la ligne de commande de lancement du serveur,</li>
<li> soit par un second serveur se connectant au serveur en lui signifiant qu'il offre un certain outil,
  disons X. Dans ce cas, le serveur principal est un proxy pour l'outil X:
  Lorsque le serveur principal recevra une requête (1) concernant l'outil
  X, il la redirigera vers le second serveur (2) offrant les services de cet outil,
  et la réponse obtenue (3) sera retransmise
  au client (4). La figure suivante illuste ce fonctionnement:
  <br/><br/>
  <img src="2servers.png" width="450" alt="" title="Example with 2 servers"/>
  <br/>
  Le second serveur peut lui aussi effectuer des requêtes auprès du serveur principal; il
  peut par exemple avoir besoin des informations du projet.
</li>
</ol>
<p>
Un environnement de développement pourrait donc comporter plusieurs outils fournis par
un serveur principal et différents serveurs secondaires, offrant chacun un ou plusieurs outils.
L'intérêt étant que l'arrêt ou la charge d'un serveur secondaire ne provoque pas de blocage
des autres outils.
</p>
<p class="center">
<img src="4servers.png" width="300" alt="" title="Example with 4 servers"/>
</p>
</section>

<section name="protocol">
<title><en>Protocol</en><fr>Protocole</fr></title>
<p>
Le protocole utilisé pour échanger requêtes et réponses est très simple.
</p>
<p>Les requêtes sont de la forme suivante:</p>
<pre class="protocol">&lt;tool&gt; [options]
&lt;command&gt;
</pre>
<p>
Par exemple, pour demander le contenu de la variable <tt>includes</tt> pour le fichier
<tt>/home/foo/test.ml</tt>, le client adressera la requête suivante au serveur,
concernant l'outil <tt>project</tt>:
</p>
<pre class="protocol">project
attribute "/home/foo/test.ml" includes
</pre>
<todo>Le format des options n'est pas encore spécifié.</todo>
<p>Le format des réponses est aussi simple:</p>
<pre class="protocol">
&lt;tool&gt; &lt;code&gt; &lt;len&gt;
&lt;contents
eventually on
more than one line, of length len&gt;
</pre>
<p>Voici par exemple la réponse possible à la requête ci-dessus:</p>
<pre class="protocol">
project 0 12
-I +lablgtk2
</pre>
<p>
Le module <tt><link href="refdoc/Odb_comm.html">Odb_comm</link></tt> offre
des fonctions pour construire, envoyer et recevoir des requêtes et des réponses.
</p>
</section>

<section name="launching-server">
<title>Lancement du serveur principal</title>
<p>
Le serveur principal est lancé par la commande
<tt class="shell">odb-server</tt> (ou <tt class="shell">odb-server.byte</tt>
pour la version bytecode). Dans la suite, nous parlerons uniquement de la version
compilée nativement, mais la correspondance des noms de fichiers pour la version
bytecode est évidente.
</p>
<p>Il est possible de charger des greffons au lancement du serveur. Ces greffons
sont des fichiers objets OCaml. Ainsi, on pourra charger le greffon <tt>foo.cmxs</tt>
de la manière suivante:
</p>
<pre class="shell">
# odb-server foo.cmxs &amp;
</pre>
<p>L'option <tt>-h</tt> donne la liste des options.</p>
</section>

<section name="creating-server">
<title>Création d'un autre serveur</title>
<p>
On peut créer un autre serveur, soit pour le lancer en tant que serveur
principal, soit pour le lancer en tant que serveur secondaire. Dans
les deux cas, on pourra ajouter un ou plusieurs nouveaux outils
à offrir à l'éditeur client.
</p>
<p>La création d'un nouveau serveur est assez simple, le code
doit faire les choses suivantes:
</p>
<ol>
<li>Créer un ou plusieurs nouveaux outils (voir <local href="tool-creation">la
section à ce sujet</local>),</li>
<li>Dans le cas d'un serveur secondaire, enregistrer ce ou ces
outils auprès du serveur principal, grâce à la fonction
<tt><link href="refdoc/Odb_client.html#VALregister_to_server">Odb_client.register_to_server</link></tt>,</li>
<li>Lancer la boucle d'attente des requêtes avec la fonction
<tt><link href="refdoc/Odb_server.html#VALstart_server">Odb_server.start_server</link></tt>.</li>
</ol>
<p>
Le <link href="http://git.ocamlcore.org/cgi-bin/gitweb.cgi?p=oug/oug.git;a=blob_plain;f=src/oug_server.ml;hb=HEAD">code du serveur de Oug</link> peut servir d'exemple.
</p>
</section>

<section name="available-tools">
<title>Documentation des outils disponibles</title>
<p>
Le serveur Odb-server de base fournit deux outils, "server" et "project".
</p>
<p>
La commande "doc" de l'outil "server" génère une page HTML contenant la
documentation des commandes disponibles pour chaque outil. Chaque outil
doit fournir une commande "doc" renvoyant la partie de HTML décrivant ses
commandes. On utilisera les fonctions du module
<tt><link href="refdoc/Odb_doc.html">Odb_doc</link></tt> pour générer
cette documentation au bon format. La commande "doc" de l'outil "server"
appelle la commande "doc" des autres outils disponibles et aggrège les
résultats dans une page HTML renvoyée en réponse. On peut voir la
page pour les outils par défaut <link href="tool_doc.html">ici</link>.
</p>
<p>
Cette page peut être facilment obtenu par la commande suivante, consistant
à lancer le server et à utiliser le client <tt>odb-client</tt> pour obtenir la
page de documentation et la rediriger dans un fichier:
</p>
<pre class="shell">
# odb-server &amp;
# odb-client "server: doc" &gt; foo.html
</pre>
</section>

<section name="tool-creation">
<title>Création d'un outil</title>
<!--The distribution includes a toy tool called "ocamlwc" usable as a starting base
to create your own tools.-->
<p>
La distribution inclus un outil jouet comme base à partir de laquelle on
peut développer ses propres outils.
</p>
<p>Le code est <a href="ocamlwc.html">ici</a>.</p>
<p>Pour compiler:
</p>
<pre class="shell">
# ocamlopt -g -shared -o ocamlwc.cmxs -thread ocamlwc.ml
</pre>
<p>Pour tester, on lance le serveur en lui donnant le greffon à charger
sur la ligne de commande:</p>
<pre class="shell">
# odb-server ocamlwc.cmxs &amp;
</pre>
<p>Pour tester, on peut utiliser le client de test. La première
commande appelle la commande "comments" de l'outil "ocamlwc" sur le
fichier "ocamlwc.ml". La seconde fait générer la documentation des outils
disponibles:
</p>
<pre class="shell">
# ./odb-client "ocamlwc: comments ocamlwc.ml"
response header: ocamlwc 0 1
8
# ./odb-client "server: doc" > /tmp/t.html
</pre>
<p>
Le module <tt><link href="refdoc/Odb_tools.html">Odb_tools</link></tt>
contient la définition des outils, les fonctions d'enregistrement, ...
</p>
</section>

<section name="author">
<title><en>Author</en><fr>Auteur</fr></title>
<p>
<link href="http://pauillac.inria.fr/~guesdon/">Maxence Guesdon</link>.
</p>
</section>
</page>
</site>
